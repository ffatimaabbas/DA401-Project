eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec) #normalize
weights
#check for consistency
eigen_values <- eig$values
principal_eigenvalue <- eigen_values[1]
c <- 6 #no. of criteria
#plugging into the formula
CI <- (principal_eigenvalue - c )/(c-1)
CIRI <- CI / 1.24
CIRI
A <- matrix(c(
1,1,2/3,1/2,2,2,
1,1,2/3,1/2,2,2,
3/2,3/2,1,3/4,3,3,
2,2,4/3,1,4,4,
1/2,1/2,1/3,1/4,1,1,
1/2,1/2,1/3,1/4,1,1
),
nrow = 6,
byrow = TRUE)
A_norm <- sweep(A, 2, colSums(A), "/")
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec) #normalize
weights
#check for consistency
eigen_values <- eig$values
principal_eigenvalue <- eigen_values[1]
c <- 6 #no. of criteria
#plugging into the formula
CI <- (principal_eigenvalue - c )/(c-1)
CIRI <- CI / 1.24
CIRI
weights
eig <- eigen(A)
w = (0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
w <- (0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
w <- list(c(0.13,0.08,0.07,0.18,0.28,0.26)) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
A
A <- matrix(0, nrow = 6, ncol = 6)
A
w(1)
w[1]
w[,1]
w[1,]
w[1,1]
w[[1]]
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
w[[1]]
A[2]
#creating a matrix using provided weights
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
pairwise_matrix <- function(w) {
n <- length(w)
A <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:n) {
A[i, j] <- w[i] / w[j]
}
}
return(A)
}
w <- c(0.13, 0.08, 0.07, 0.18, 0.28, 0.26)
A <- pairwise_matrix(w)
A
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec) #normalize
weights
eigen_values <- eig$values
principal_eigenvalue <- eigen_values[1]
c <- 6 #no. of criteria
#plugging into the formula
CI <- (principal_eigenvalue - c )/(c-1)
CIRI <- CI / 1.24
CIRI
CIRI
A_norm <- sweep(A, 2, colSums(A), "/")
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec) #normalize
weights
#check for consistency
eigen_values <- eig$values
principal_eigenvalue <- eigen_values[1]
c <- 6 #no. of criteria
principal_eigenvalue
A
A <- matrix(c(
1,     1/4,   1/3,   1/3,   7,
4,     1,     2,     3,     7,
3,     1/2,   1,     3,     6,
3,     1/3,   1/3,   1,     4,
1/7,   1/7,   1/6,   1/4,   1
), nrow = 5, byrow = TRUE)
A
A_norm <- sweep(A, 2, colSums(A), "/")
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec) #normalize
weights
#check for consistency
eigen_values <- eig$values
principal_eigenvalue <- eigen_values[1]
c <- 5 #no. of criteria
#plugging into the formula
CI <- (principal_eigenvalue - c )/(c-1)
CIRI <- CI / 1.12
CIRI
source("~/testing_ouma.R")
#creating a matrix using provided weights by ouma & tateishi
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
pairwise_matrix <- function(w) {
n <- length(w)
A <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:n) {
A[i, j] <- w[i] / w[j]
}
}
return(A)
}
w <- c(0.13, 0.08, 0.07, 0.18, 0.28, 0.26)
A <- pairwise_matrix(w)
A
A <- A[-5,-5]
A
eigen_values <- eig$values
principal_eigenvalue <- eigen_values[1]
c <- 5 #no. of criteria
#plugging into the formula
CI <- (principal_eigenvalue - c )/(c-1)
CIRI <- CIRI / 1.12
CIRI
CIRI
A <- matrix(c(
1,     1/4,   1/3,   1/3,   7,
4,     1,     2,     3,     7,
3,     1/2,   1,     3,     6,
3,     1/3,   1/3,   1,     4,
1/7,   1/7,   1/6,   1/4,   1
), nrow = 5, byrow = TRUE)
A
A_norm <- sweep(A, 2, colSums(A), "/")
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec) #normalize
weights
#check for consistency
eigen_values <- eig$values
principal_eigenvalue <- eigen_values[1]
c <- 5 #no. of criteria
#plugging into the formula
CI <- (principal_eigenvalue - c )/(c-1)
CIRI <- CI / 1.12
CIRI
principal_eigenvalue <- eigen_values[1]
principal_eigenvalue
x
#creating a matrix using provided weights by ouma & tateishi
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
pairwise_matrix <- function(w) {
n <- length(w)
A <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:n) {
A[i, j] <- w[i] / w[j]
}
}
return(A)
}
w <- c(0.13, 0.08, 0.07, 0.18, 0.28, 0.26)
A <- pairwise_matrix(w)
A
#removing soil because that is not a relevant variable for our study
A <- A[-5,-5]
#method 1: normalization
A_norm <- sweep(A, 2, colSums(A), "/")
#method 2: eigenvectors
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec) #normalized weight vector, we see that this is the same regardless of the method we pick
#check for consistency
eigen_values <- eig$values
principal_eigenvalue <- eigen_values[1]
c <- 5 #no. of criteria
#plugging into the formula
CI <- (principal_eigenvalue - c )/(c-1)
CIRI <- CI / 1.12
principal_eigenvalue
CI
CIRI
CIRI <- CI / 1.12
CIRI
CIRI
#creating a matrix using provided weights by ouma & tateishi
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
pairwise_matrix <- function(w) {
n <- length(w)
A <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:n) {
A[i, j] <- w[i] / w[j]
}
}
return(A)
}
w <- c(0.13, 0.08, 0.07, 0.18, 0.28, 0.26)
A <- pairwise_matrix(w)
A
#removing soil because that is not a relevant variable for our study
A <- A[-5,-5]
#method 1: normalization
A_norm <- sweep(A, 2, colSums(A), "/")
#method 2: eigenvectors
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec) #normalized weight vector, w
weights
#creating a matrix using provided weights
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
pairwise_matrix <- function(w) {
n <- length(w)
A <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:n) {
A[i, j] <- w[i] / w[j]
}
}
return(A)
}
w <- c(0.13, 0.08, 0.07, 0.18, 0.28, 0.26)
A <- pairwise_matrix(w)
A
A_norm <- sweep(A, 2, colSums(A), "/")
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec) #normalize
weights
weights
#creating a matrix using provided weights
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
pairwise_matrix <- function(w) {
n <- length(w)
A <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:n) {
A[i, j] <- w[i] / w[j]
}
}
return(A)
}
w <- c(0.13, 0.08, 0.07, 0.18, 0.28, 0.26)
A <- pairwise_matrix(w)
A
A_norm <- sweep(A, 2, colSums(A), "/")
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec) #normalize
weights
#creating a matrix using provided weights
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
pairwise_matrix <- function(w) {
n <- length(w)
A <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:n) {
A[i, j] <- w[i] / w[j]
}
}
return(A)
}
w <- c(0.13, 0.08, 0.07, 0.18, 0.28, 0.26)
A <- pairwise_matrix(w)
A
A_norm <- sweep(A, 2, colSums(A), "/")
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec) #normalize
weights
A%*%weights
6.55%*%weights
5%*%w
5%*%weights
#creating a matrix using provided weights by ouma & tateishi
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
pairwise_matrix <- function(w) {
n <- length(w)
A <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:n) {
A[i, j] <- w[i] / w[j]
}
}
return(A)
}
w <- c(0.13, 0.08, 0.07, 0.18, 0.28, 0.26)
A <- pairwise_matrix(w)
A
#removing soil because that is not a relevant variable for our study
A <- A[-5,-5]
#method 2: updated weights using eigenvectors after removing soil
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec)
A%*%weights
5%*%weights
6.55%*%weights
A%*%weights = 5%*%weights
A%*%weights == 5%*%weights
A%*%weights
5%*%weights
A%*%weights == t(5%*%weights)
t(A%*%weights) == 5%*%weights
#creating a matrix using provided weights by ouma & tateishi
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
pairwise_matrix <- function(w) {
n <- length(w)
A <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:n) {
A[i, j] <- w[i] / w[j]
}
}
return(A)
}
w <- c(0.13, 0.08, 0.07, 0.18, 0.28, 0.26)
A <- pairwise_matrix(w)
A
#removing soil because that is not a relevant variable for our study
A <- A[-5,-5]
#method 2: updated weights using eigenvectors after removing soil
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec)
#check for consistency
eigen_values <- eig$values
principal_eigenvalue <- eigen_values[1]
c <- 5 #no. of criteria
#plugging into the formula
CI <- (principal_eigenvalue - c )/(c-1)
CIRI <- CI / 1.12
CIRI
#to make sure our code is right, we check the following:
t(A%*%weights) == 5%*%weights
t(A%*%weights) == 5%*%weights
t(A%*%weights)
5%*%weights
t(A%*%weights) == 5%*%weights
all.equal((t(A%*%weights), 5%*%weights))
all.equal((t(A%*%weights), 5%*%weights))
all.equal(t(A%*%weights), 5%*%weights)
#creating a matrix using provided weights by ouma & tateishi
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
pairwise_matrix <- function(w) {
n <- length(w)
A <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:n) {
A[i, j] <- w[i] / w[j]
}
}
return(A)
}
w <- c(0.13, 0.08, 0.07, 0.18, 0.28, 0.26)
A <- pairwise_matrix(w)
A
#removing soil because that is not a relevant variable for our study
A <- A[-5,-5]
#method 2: updated weights using eigenvectors after removing soil
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec)
#check for consistency
eigen_values <- eig$values
principal_eigenvalue <- eigen_values[1]
c <- 5 #no. of criteria
#plugging into the formula
CI <- (principal_eigenvalue - c )/(c-1)
CIRI <- CI / 1.12
CIRI
#to make sure our code is right, we check the following condition is true:
all.equal(t(A%*%weights), 5%*%weights)
#creating a matrix using provided weights by ouma & tateishi
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
pairwise_matrix <- function(w) {
n <- length(w)
A <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:n) {
A[i, j] <- w[i] / w[j]
}
}
return(A)
}
w <- c(0.13, 0.08, 0.07, 0.18, 0.28, 0.26)
A <- pairwise_matrix(w)
A
source("~/Documents/DA401-Project/Code/weights.R")
#creating a matrix using provided weights by ouma & tateishi
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
pairwise_matrix <- function(w) {
n <- length(w)
A <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:n) {
A[i, j] <- w[i] / w[j]
}
}
return(A)
}
w <- c(0.13, 0.08, 0.07, 0.18, 0.28, 0.26)
A <- pairwise_matrix(w)
A
install.packages("fractional")
fraction_A <- fractional(A) #showing as fractions to report
library(fraction)
fraction_A <- fractional(A) #showing as fractions to report
library(fractionol)
library(fractional)
fraction_A <- fractional(A) #showing as fractions to report
fraction_A
A <- A[-5,-5]
#updated weights using eigenvectors after removing soil
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec)
weights
library(fractional)
#creating a matrix using provided weights by ouma & tateishi
w <- list(0.13,0.08,0.07,0.18,0.28,0.26) #Rainfall, Drainage, Elevation, Slope, Soil, Land-use
pairwise_matrix <- function(w) {
n <- length(w)
A <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:n) {
A[i, j] <- w[i] / w[j]
}
}
return(A)
}
w <- c(0.13, 0.08, 0.07, 0.18, 0.28, 0.26)
A <- pairwise_matrix(w)
A
fraction_A <- fractional(A) #showing as fractions to report
#removing soil because that is not a relevant variable for our study
A <- A[-5,-5]
#updated weights using eigenvectors after removing soil
eig <- eigen(A)
principal_eigvec <- eig$vectors[,1] #get principal eigenvector
weights <- principal_eigvec / sum(principal_eigvec)
weights
#install.packages("foreign")
library(foreign)
table1 <-read.dbf("District_FloodRisk.dbf", as.is = FALSE)
library(foreign)
table1 <-read.dbf("District_FloodRisk.dbf", as.is = FALSE)
library(foreign)
table2 <- read.dbf("Study_area.dbf", as.is = FALSE)
setwd("~/Documents/DA401-Project")
setwd("~/Documents/DA401-Project/Attribute tables")
table2 <- read.dbf("Study_area.dbf", as.is = FALSE)
table1 <-read.dbf("floodrisk_bydistrict.dbf", as.is = FALSE)
#install.packages("foreign")
library(foreign)
table1 <-read.dbf("floodrisk_bydistrict.dbf", as.is = FALSE)
table2 <- read.dbf("Study_area.dbf", as.is = FALSE)
head(table1)
head(table2)
table2$Value <- 1:nrow(table2) #adding value col so i can left join
floodrisk_district <- left_join(table1, table2, by = "Value")
library(dplyr)
library(readr)
library(foreign)
library(dplyr)
table1 <-read.dbf("floodrisk_bydistrict.dbf", as.is = FALSE)
table2 <- read.dbf("Study_area.dbf", as.is = FALSE)
head(table1)
head(table2)
table2$Value <- 1:nrow(table2) #adding value col so i can left join
floodrisk_district <- left_join(table1, table2, by = "Value")
#next, we add educ table
literacy <- read.csv("district_literacy_rates.csv")
literacy$District <- toupper(literacy$District)
literacy <- literacy %>% rename(DISTRICT = District)
district_info <- left_join(floodrisk_district, literacy, by = "DISTRICT") #added district literacy rates to full table
district_clean <- district_info[!is.na(district_info$Literacy.Rate), ]
floodrisk_education <- lm(Literacy.Rate ~ MAJORITY, data = district_clean)
summary(floodrisk_education)
plot(district_clean$Literacy.Rate, district_clean$MAJORITY)
texreg(floodrisk_education)
library(readr)
library(foreign)
library(dplyr)
table1 <-read.dbf("floodrisk_bydistrict.dbf", as.is = FALSE)
table2 <- read.dbf("Study_area.dbf", as.is = FALSE)
head(table1)
head(table2)
table2$Value <- 1:nrow(table2) #adding value col so i can left join
floodrisk_district <- left_join(table1, table2, by = "Value")
#next, we add educ table
literacy <- read.csv("district_literacy_rates.csv")
literacy$District <- toupper(literacy$District)
literacy <- literacy %>% rename(DISTRICT = District)
district_info <- left_join(floodrisk_district, literacy, by = "DISTRICT") #added district literacy rates to full table
district_clean <- district_info[!is.na(district_info$Literacy.Rate), ]
floodrisk_education <- lm(Literacy.Rate ~ MAJORITY, data = district_clean)
summary(floodrisk_education)
plot(district_clean$Literacy.Rate, district_clean$MAJORITY)
summary(floodrisk_education)
